'use strict';
const modularExponentiation = require('../../common/math/modular-exponentiation').modularExponentiation;

// use pre-computed values as a starting point as repeated modular exponentiation is known to be slow in javascript
let selfPowersLookup = new Map([
  [1, 0],
  [10000, 6237204500],
  [20000, 2601046500],
  [30000, 9784888500],
  [40000, 7788730500],
  [50000, 6612572500],
  [60000, 6256414500],
  [70000, 6720256500],
  [80000, 8004098500],
  [90000, 107940500],
  [100000, 3031782500],
  [110000, 6775624500],
  [120000, 1339466500],
  [130000, 6723308500],
  [140000, 2927150500],
  [150000, 9950992500],
  [160000, 7794834500],
  [170000, 6458676500],
  [180000, 5942518500],
  [190000, 6246360500],
  [200000, 7370202500],
  [210000, 9314044500],
  [220000, 2077886500],
  [230000, 5661728500],
  [240000, 65570500],
  [250000, 5289412500],
  [260000, 1333254500],
  [270000, 8197096500],
  [280000, 5880938500],
  [290000, 4384780500],
  [300000, 3708622500],
  [310000, 3852464500],
  [320000, 4816306500],
  [330000, 6600148500],
  [340000, 9203990500],
  [350000, 2627832500],
  [360000, 6871674500],
  [370000, 1935516500],
  [380000, 7819358500],
  [390000, 4523200500],
  [400000, 2047042500],
  [410000, 390884500],
  [420000, 9554726500],
  [430000, 9538568500],
  [440000, 342410500],
  [450000, 1966252500],
  [460000, 4410094500],
  [470000, 7673936500],
  [480000, 1757778500],
  [490000, 6661620500],
  [500000, 2385462500],
  [510000, 8929304500],
  [520000, 6293146500],
  [530000, 4476988500],
  [540000, 3480830500],
  [550000, 3304672500],
  [560000, 3948514500],
  [570000, 5412356500],
  [580000, 7696198500],
  [590000, 800040500],
  [600000, 4723882500],
  [610000, 9467724500],
  [620000, 5031566500],
  [630000, 1415408500],
  [640000, 8619250500],
  [650000, 6643092500],
  [660000, 5486934500],
  [670000, 5150776500],
  [680000, 5634618500],
  [690000, 6938460500],
  [700000, 9062302500],
  [710000, 2006144500],
  [720000, 5769986500],
  [730000, 353828500],
  [740000, 5757670500],
  [750000, 1981512500],
  [760000, 9025354500],
  [770000, 6889196500],
  [780000, 5573038500],
  [790000, 5076880500],
  [800000, 5400722500],
  [810000, 6544564500],
  [820000, 8508406500],
  [830000, 1292248500],
  [840000, 4896090500],
  [850000, 9319932500],
  [860000, 4563774500],
  [870000, 627616500],
  [880000, 7511458500],
  [890000, 5215300500],
  [900000, 3739142500],
  [910000, 3082984500],
  [920000, 3246826500],
  [930000, 4230668500],
  [940000, 6034510500],
  [950000, 8658352500],
  [960000, 2102194500],
  [970000, 6366036500],
  [980000, 1449878500],
  [990000, 7353720500],
  [1000000, 4077562500]
]);

/**
 * Find the last x digits of the series 1^1 + 2^2 + 3^3 + ... + n^n
 * @param {Number} n
 * @param {Number} digits the remaining digits to return
 * @returns {Number}
 */
exports.selfPowers = (n, digits) => {
  let modulo = Math.pow(10, digits);

  let start = Array.from(selfPowersLookup).map(([key, value]) => ({ key, value })).reduce((previous, current) =>
    current.key <= n ? current : previous
  );

  let current = start.value;
  for (let i = start.key; i <= n; i++) {
    if (i % 10 !== 0) {
      let value = modularExponentiation(i, i, modulo);
      current += value;
      current %= modulo;
    }
  }

  return current;
};
