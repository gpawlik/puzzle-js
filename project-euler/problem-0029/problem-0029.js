'use strict';
const prime = require('../../common/math/prime');

/**
 * Finds the number of distinct terms in the sequence generated by a^b for 2 ≤ a ≤ max and 2 ≤ b ≤ max
 * @param {Number} max
 * @returns {Number}
 */
exports.distinctPowers = (max) => {
  // get the total number of combinations, including duplicates 
  let result = Math.pow((max - 1), 2);

  // calculate the number of powers to check, eg 2^x<=max (2^6<=100)
  let powers = parseInt(Math.log2(max));

  // check the highest powers first to find numbers a that can be raised to the
  // square, cube, 4th, 5th, 5th, etc. power
  for (let power = 2; power <= powers; power++) {

    // all numbers for a that can be written as a number to the ^power and not a larger power
    // will have the same number of duplicates that will need to be removed.
    // calculate that number by scanning from b to max to find possible duplicates
    let duplicateCount = 0;
    for (let b = 2; b <= max; b++) {
      let isDuplicate = false;
      for (let c = 1; c <= power - 1; c++) {
        let x = power * (b / c);
        if (Number.isInteger(x) && x <= max) {
          isDuplicate = true;
        }
      }
      if (isDuplicate) {
        duplicateCount++;
      }
    }

    // now reduce the total combinations by the number of duplicates for a power
    // for all unique powers that can't be expressed as a higher power
    //for (let a = 2; a <= parseInt(power === 3 ? Math.cbrt(max) : Math.pow(max, 1 / power)); a++) {
    for (let a = 2; a <= parseInt(exports.nthRoot(max, power)); a++) {
      let factor = Math.pow(a, power);
      let primeFactorization = prime.primeFactorization(factor);
      let maxExponent = primeFactorization.reduce((prev, curr) => Math.max(prev, curr.exponent), 0);
      if (maxExponent === power || primeFactorization.length > 1) {
        // remove the number of duplicates for the factor a^power, where factor is a square, cube, or higher power
        result -= duplicateCount;
      }
    }
  }

  return result;
};

exports.nthRoot = (value, root) => {
  if (root === 2) {
    return Math.sqrt(value);
  } else if (root === 3) {
    return Math.cbrt(value);
  } else {
    return Math.pow(value, 1 / root);
  }
};