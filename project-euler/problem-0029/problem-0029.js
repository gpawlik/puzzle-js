'use strict';

/**
 * Finds the number of distinct terms in the sequence generated by a^b for 2 ≤ a ≤ max and 2 ≤ b ≤ max
 * @param {Number} max
 * @returns {Number}
 */
exports.distinctPowers = (max) => {
  // get the total number of combinations, including duplicates 
  let result = Math.pow((max - 1), 2);

  // calculate the number of powers to check, eg 2^x<=max (2^6<=100)
  let powers = parseInt(Math.log2(max));
  let factors = new Set();

  // check the highest powers first to find numbers a that can be raised to the
  // square, cube, 4th, 5th, 5th, etc. power
  for (let power = powers; power >= 2; power--) {

    // all numbers for a that can be written as a number to the ^power and not a larger power
    // will have the same number of duplicates that will need to be removed.
    // calculate that number by scanning from b to max to find possible duplicates
    let duplicateCount = 0;
    for (let b = 2; b <= max; b++) {
      let isDuplicate = false;
      for (let c = 1; c <= power - 1; c++) {
        let x = power * b / c;
        if (Number.isInteger(x) && x <= max) {
          isDuplicate = true;
          break;
        }
      }
      if (isDuplicate) {
        duplicateCount++;
      }
    }

    // now reduce the total combinations by the number of duplicates for a power
    // for all unique powers that can't be expressed as a higher power
    for (let a = 2; a <= parseInt(exports.nthRoot(max, power)); a++) {
      let factor = Math.pow(a, power);
      if (!factors.has(factor)) {
        factors.add(factor);
        result -= duplicateCount;
      }
    }
  }

  return result;
};

exports.nthRoot = (value, root) => {
  if (root === 3) {
    return Math.cbrt(value);
  } else {
    return Math.pow(value, 1 / root);
  }
};